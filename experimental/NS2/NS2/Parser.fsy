%{
open System
open NS2.Ast
%}

%start main
%type <NS2.Ast.AST> main

%token <int> INT
%token <string> ID
%token <string> STRING
%token <string> OPEQ
%token 
	PLUS MINUS TIMES DIVIDE AT PIPE HASH 
	EQ NEQ EQEQ GE LE GEQ LEQ AND OR NOT MODULO
	LPAREN RPAREN LBRACK RBRACK LCURLY RCURLY
	COMMA SEMICOLON COLON
	IF ELSE WHILE
	EOF

%left PLUS MINUS
%left TIMES DIVIDE
%left AT

%%

main:
	  body_list             { Root $1 }
	| body_list SEMICOLON   { Root $1 }

expr:
      LPAREN expr RPAREN 				{ $2 }
	| expr op expr	 				    { Binop ($1, $2, $3) }
	| expr PLUS expr	 				{ Binop ($1, "+", $3) }
	| expr MINUS expr					{ Binop ($1, "-", $3) }
	| expr TIMES expr					{ Binop ($1, "*", $3) }
	| expr DIVIDE expr 					{ Binop ($1, "/", $3) }
	| expr AT expr 						{ Index ($1, $3) }
	| expr OPEQ expr                    { Assign ($1, Binop($1, $2[..$2.Length-2], $3))}
	| expr EQ expr                      { Assign ($1, $3)}
	| expr EQ funcblock                 { Assign ($1, $3)}
	| op expr                           { Unaryop ($1, $2)}
	| if_expr                           { $1 }
	| while_expr                        { $1 }
	| arr 								{ $1 }
	| pipe_expr 						{ Pipe $1 }
	| expr funcblock 					{ Map ($1, $2) }
	| INT								{ Int $1 }
	| STRING							{ String $1 }
	| op								{ Id $1 }
	| call							    { $1 }
	| ID								{ Id $1 }
	
op:
      EQEQ      { "==" }
    | NEQ       { "!=" }
    | GE        { ">"  }
    | LE        { "<"  }
    | GEQ       { ">=" }
    | LEQ       { "<=" }
    | AND       { "&&" }
    | OR        { "||" }
    | HASH      { "#"  }
    | NOT       { "!"  }
    | MODULO    { "%"  }

while_expr:
    WHILE LPAREN expr RPAREN while_body { While ($3,$5) }
    
while_body:
      expr                              {$1}
    | block                             {$1}  

if_expr:
      IF LPAREN expr RPAREN if_body ELSE if_body       {If($3,$5,Some $7)}
    | IF LPAREN expr RPAREN if_body                    {If($3,$5, None)}

if_body:
      expr                              {$1}
    | block                             {$1}    

pipe_expr:
      pipe_entry PIPE pipe_entry              { [$1;$3] }
    | pipe_entry PIPE pipe_expr               { $1::$3 }
    
pipe_entry:
      expr                              {$1}
    | funcblock                         {$1}

arr:
	  LBRACK RBRACK						{ Array [] }
	| LBRACK element_list RBRACK		{ Array $2 }

element_list:
	  expr								{ [$1] }
	| expr COMMA element_list 			{ $1 :: $3 }

funcblock:
    block                               { Func $1 }

block:
	  LCURLY RCURLY						{ Block [] }
	| LCURLY body_list RCURLY			{ Block $2 }
	
body_list:
	  expr								{ [$1] }
	| expr SEMICOLON					{ [$1] }
	| expr SEMICOLON body_list 			{ $1 :: $3 }
	
call:
    ID COLON arg_list                         { Call ($1, $3)}

arg_list:
	  expr								{ [$1] }
	| expr arg_list 			        { $1 :: $2 }
    
    