%{
open System
open NS2.Ast
%}

%start main
%type <NS2.Ast.AST> main

%token <int> INT
%token <string> ID
%token <string> STRING
%token <string> OP
%token <string> OPEQ
%token 
	PLUS MINUS TIMES DIVIDE AT PIPE
	LPAREN RPAREN LBRACK RBRACK LCURLY RCURLY
	EQ
	COMMA SEMICOLON
	IF ELSE
	EOF

%left PLUS MINUS
%left TIMES DIVIDE
%left AT

%%

main:
	body_list { Root $1 }

expr:
      LPAREN expr RPAREN 				{ $2 }
	| expr OP expr	 				    { Binop ($1, $2, $3) }
	| expr PLUS expr	 				{ Binop ($1, "+", $3) }
	| expr MINUS expr					{ Binop ($1, "-", $3) }
	| expr TIMES expr					{ Binop ($1, "*", $3) }
	| expr DIVIDE expr 					{ Binop ($1, "/", $3) }
	| expr AT expr 						{ Index ($1, $3) }
	| expr OPEQ expr                    { Assign ($1, Binop($1, $2[..$2.Length-2], $3))}
	| expr EQ expr                      { Assign ($1, $3)}
	| expr EQ funcblock                 { Assign ($1, $3)}
	| OP expr                           { Unaryop ($1, $2)}
	| arr 								{ $1 }
	| pipe_expr 						{ Pipe $1 }
	| expr funcblock 					{ Map ($1, $2) }
	| INT								{ Int $1 }
	| STRING							{ String $1 }
	| call							    { $1 }
	| ID								{ Id $1 }
	| OP								{ Id $1 }

pipe_expr:
      pipe_entry PIPE pipe_entry              { [$1;$3] }
    | pipe_entry PIPE pipe_expr               { $1::$3 }
    
pipe_entry:
      expr                              {$1}
    | funcblock                         {$1}

arr:
	  LBRACK RBRACK						{ Array [] }
	| LBRACK element_list RBRACK		{ Array $2 }

element_list:
	  expr								{ [$1] }
	| expr COMMA element_list 			{ $1 :: $3 }

funcblock:
    block                               { Func $1 }

block:
	  LCURLY RCURLY						{ Block [] }
	| LCURLY body_list RCURLY			{ Block $2 }
	
body_list:
	  expr								{ [$1] }
	| expr SEMICOLON					{ [$1] }
	| expr SEMICOLON body_list 			{ $1 :: $3 }
	
call:
    ID arg_list                         { Call ($1, $2)}

arg_list:
	  expr								{ [$1] }
	| expr arg_list 			        { $1 :: $2 }
    
    